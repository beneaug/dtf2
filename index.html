<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Lovable Gradient Background</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="page-root">
      <!-- Scraped background wrapper from lovable.dev (structure preserved) -->
      <div class="bg-gradient-root">
        <div class="bg-gradient-wrapper">
          <div class="bg-gradient-image"></div>
        </div>
        <div class="bg-grain-overlay"></div>
      </div>

      <!-- Foreground content -->
      <main class="page-content">
        <section class="hero">
          <h1>Finally, DTF you're gonna love.</h1>
          <p>Organized and orchestrated by 12ozCollective</p>
        </section>

        <section class="copy-section">
          <h2>Consistent peels, less waste.</h2>
          <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam
            laoreet, arcu ut iaculis pulvinar, ligula nisl convallis nibh, vel
            pharetra est mauris id libero. Praesent a justo ac lorem aliquet
            malesuada at vel justo.
          </p>
        </section>

        <section class="copy-section">
          <h2>Unmatched vibrancy and depth</h2>
          <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Integer
            porttitor turpis ac nibh tempor, at lacinia eros placerat. Sed
            hendrerit accumsan augue, eu vestibulum erat bibendum vitae.
          </p>
          <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras at
            odio quis urna viverra gravida sit amet in urna.
          </p>
        </section>

        <section class="copy-section copy-section--last">
          <h2>Built for shops that never sleep</h2>
          <p>
            Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas
            luctus, lorem a commodo hendrerit, justo nisl consequat lectus, at
            tincidunt nisl ante eget nisl. Suspendisse tempor, neque a
            ullamcorper vulputate, velit lorem cursus urna, vitae gravida sem
            arcu vel velit.
          </p>
        </section>
      </main>

      <footer class="page-footer">
        <img
          src="https://raw.githubusercontent.com/beneaug/embroideryestimator/refs/heads/main/12ozcollective-logo-Bx1lkEfX.png"
          alt="12ozCollective logo"
          class="footer-logo"
        />
      </footer>
    </div>
    <script>
      (function () {
        var image = document.querySelector(".bg-gradient-image");
        var hero = document.querySelector(".hero");
        var sections = document.querySelectorAll(".copy-section");
        var secondSection = sections.length > 1 ? sections[1] : null;

        var gradientConfig = {
          heroY: 0,
          dockY: -580, // initial values; refined responsively in recalcGradientBounds
          heroScale: 1,
          dockScale: 0.25, // initial; refined responsively
          heroOffsetX: 0, // centered under hero
          dockOffsetX: -220, // initial; refined responsively
          toDockStart: 0,
          toDockEnd: 1,
          returnStart: 1,
          returnEnd: 1,
          scrollMax: 1
        };

        function recalcGradientBounds() {
          if (!hero || !secondSection) return;
          var heroHeight = hero.offsetHeight || window.innerHeight || 1;
          var secondTop = secondSection.offsetTop;
          var vh = window.innerHeight || document.documentElement.clientHeight;
          var vw = window.innerWidth || document.documentElement.clientWidth;
          var doc = document.documentElement;
          var body = document.body;
          var scrollHeight = Math.max(
            body.scrollHeight,
            body.offsetHeight,
            doc.clientHeight,
            doc.scrollHeight,
            doc.offsetHeight
          );
          var scrollMax = scrollHeight - vh;

          // Responsive dock + hero positions based on viewport so the effect
          // stays visually consistent across desktop and mobile.
          var heading = secondSection.querySelector("h2");
          var headingRect = heading ? heading.getBoundingClientRect() : null;
          if (vw >= 1200) {
            // Large desktop: small, tight blob very high and left of the color section
            gradientConfig.heroY = 0;
            gradientConfig.dockScale = 0.17;
            gradientConfig.dockY = -1.0 * vh; // sit even higher on very large displays
            if (headingRect) {
              // place the blob left of the heading text, based on its actual position
              var targetXDesktop = headingRect.left - 80;
              gradientConfig.dockOffsetX = targetXDesktop - vw / 2;
            } else {
              gradientConfig.dockOffsetX = -0.26 * vw;
            }
          } else if (vw >= 768) {
            // Laptop / tablet landscape  (LOCKED: do not tweak this branch)
            gradientConfig.heroY = 0;
            gradientConfig.dockScale = 0.22;
            gradientConfig.dockY = -0.6 * vh; // slightly lower dock for laptops
            // Horizontal offset left as-is for laptops
            gradientConfig.dockOffsetX = -0.22 * vw;
          } else {
            // MOBILE ONLY:
            // Start with the blob far below the viewport and heavily zoomed in,
            // then shrink toward the second text element, and finally grow back
            // to a huge state so the page keeps a consistent gradient background.
            gradientConfig.heroY = 1.2 * vh; // even lower (further down) on the page
            gradientConfig.dockY = gradientConfig.heroY; // anchor vertically; scale does the work
            gradientConfig.heroScale = 2.2; // slightly larger starting blob on mobile
            gradientConfig.dockScale = 0.776; // ~3% smaller than 0.8 for a tighter dock

            if (headingRect) {
              var targetXMobile = headingRect.left + headingRect.width * 0.1;
              gradientConfig.dockOffsetX = targetXMobile - vw / 2;
            } else {
              gradientConfig.dockOffsetX = -0.04 * vw;
            }
          }

          // start travelling essentially as soon as the user scrolls
          gradientConfig.toDockStart = 0;
          // reach docked state with less scroll distance (sooner)
          gradientConfig.toDockEnd = secondTop - vh * 0.2;
          if (gradientConfig.toDockEnd <= gradientConfig.toDockStart) {
            gradientConfig.toDockEnd = gradientConfig.toDockStart + vh * 0.5;
          }

          // begin returning over the bottom portion of the page, but leave a plateau
          // after docking so it can "hang out" near the color section
          gradientConfig.returnStart = scrollMax * 0.6;
          // On ultraâ€‘wide displays, start the return a bit earlier so it feels softer
          if (vw >= 1200) {
            gradientConfig.returnStart = scrollMax * 0.55;
          } else if (vw < 768) {
            // On mobile, stretch the return over a longer range for a more graceful feel
            gradientConfig.returnStart = scrollMax * 0.5;
          }
          gradientConfig.returnEnd = scrollMax;
          gradientConfig.scrollMax = scrollMax;
        }

        function clamp01(v) {
          return v < 0 ? 0 : v > 1 ? 1 : v;
        }

        function easeInOutCubic(x) {
          x = clamp01(x);
          return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 1, 3) / 2;
        }

        function onScroll() {
          var scrollY = window.scrollY || window.pageYOffset || 0;

          if (image && secondSection) {
            var y, scale, offsetX;

            if (scrollY <= gradientConfig.toDockStart) {
              y = gradientConfig.heroY;
              scale = gradientConfig.heroScale;
              offsetX = gradientConfig.heroOffsetX;
            } else if (scrollY <= gradientConfig.toDockEnd) {
              var t =
                (scrollY - gradientConfig.toDockStart) /
                (gradientConfig.toDockEnd - gradientConfig.toDockStart);
              t = clamp01(t);
              y =
                gradientConfig.heroY +
                (gradientConfig.dockY - gradientConfig.heroY) * t;
              scale =
                gradientConfig.heroScale +
                (gradientConfig.dockScale - gradientConfig.heroScale) * t;
              offsetX =
                gradientConfig.heroOffsetX +
                (gradientConfig.dockOffsetX - gradientConfig.heroOffsetX) * t;
            } else if (scrollY < gradientConfig.returnStart) {
              y = gradientConfig.dockY;
              scale = gradientConfig.dockScale;
              offsetX = gradientConfig.dockOffsetX;
            } else {
              var uLinear =
                (scrollY - gradientConfig.returnStart) /
                (gradientConfig.returnEnd - gradientConfig.returnStart || 1);
              var u = easeInOutCubic(uLinear);
              y =
                gradientConfig.dockY +
                (gradientConfig.heroY - gradientConfig.dockY) * u;
              scale =
                gradientConfig.dockScale +
                (gradientConfig.heroScale - gradientConfig.dockScale) * u;
              offsetX =
                gradientConfig.dockOffsetX +
                (gradientConfig.heroOffsetX - gradientConfig.dockOffsetX) * u;
            }

            image.style.setProperty("--gradient-y", y.toFixed(2) + "px");
            image.style.setProperty(
              "--gradient-scale",
              scale.toFixed(3)
            );
            image.style.setProperty(
              "--gradient-offset-x",
              offsetX.toFixed(2) + "px"
            );
          }

          if (hero) {
            var heroHeight2 = hero.offsetHeight || window.innerHeight || 1;
            var progress = scrollY / heroHeight2;
            if (progress < 0) progress = 0;
            if (progress > 1) progress = 1;

            var translateY = -40 * progress;
            var scaleHero = 1 - 0.04 * progress;
            var opacity = 1 - 0.35 * progress;

            hero.style.transform =
              "translate3d(0, " +
              translateY.toFixed(2) +
              "px, 0) scale(" +
              scaleHero.toFixed(3) +
              ")";
            hero.style.opacity = opacity.toFixed(3);
          }
        }

        recalcGradientBounds();
        window.addEventListener("scroll", onScroll, { passive: true });
        window.addEventListener("resize", function () {
          recalcGradientBounds();
          onScroll();
        });
        onScroll();

        if ("IntersectionObserver" in window && sections.length) {
          var observer = new IntersectionObserver(
            function (entries) {
              entries.forEach(function (entry) {
                if (entry.isIntersecting) {
                  entry.target.classList.add("copy-section--visible");
                  observer.unobserve(entry.target);
                }
              });
            },
            { threshold: 0.3 }
          );

          sections.forEach(function (section) {
            observer.observe(section);
          });
        } else {
          sections.forEach(function (section) {
            section.classList.add("copy-section--visible");
          });
        }
      })();
    </script>
  </body>
</html>


